#include <iostream>
#include <vector>
#include <algorithm>
#include <math.h>
#include "macro.h"
#include "graph.h"
#include "strategies.h"
#include "transitive_reduction.h"
#include "corner_stitch/utils/update.h"
#include "constraint_graph.h"

extern double chip_width, chip_height, min_spacing, buffer_constraint, powerplan_width, alpha, beta;
extern int micron;
extern int macros_num;

static int collectSolidTiles(Tile *tile, ClientData cdata){
	if(TiGetBody(tile) == SOLID_TILE)
		((vector<Tile*>*) cdata)->push_back(tile);
	return 0;
}

static int empty_region(Tile *tile, ClientData cdata){
	if(TiGetBody(tile) == SOLID_TILE)
		*((bool*)cdata) = false;
	return 0;
}

void improve_strategy1(vector<Macro*>& macro, vector<Macro*>& native_macro, Plane* horizontal_plane, Graph& Gh, Graph& Gv){

	// Strategy 1: adjust macros near boundary
	vector<edge>* h_edge_list = Gh.get_edge_list();
	vector<edge>* v_edge_list = Gv.get_edge_list();
	vector<edge>* r_h_edge_list = Gh.get_reverse_edge_list();
	vector<edge>* r_v_edge_list = Gv.get_reverse_edge_list();

	// near left
	for(int i = 0; i < h_edge_list[0].size(); i++){
		int m = h_edge_list[0][i].to - 1;
		if(macro[m]->x1() < powerplan_width && macro[m]->x1() != 0 && !macro[m]->is_fixed()){
			if(alpha * macro[m]->x1() < beta * sqrt(macro[m]->x1() * macro[m]->h())){
				macro[m]->updateXY(make_pair(macro[m]->w() / 2, macro[m]->cy()));
			}
		}
	}
	// near right
	for(int i = 0; i < r_h_edge_list[macro.size() + 1].size(); i++){
		int m = r_h_edge_list[macro.size() + 1][i].from - 1;
		if((macro[m]->x2() > (chip_width - powerplan_width)) && macro[m]->x2() != chip_width && !macro[m]->is_fixed()){
			if(alpha * macro[m]->x2() < beta * sqrt(macro[m]->x2() * macro[m]->h())){
				macro[m]->updateXY(make_pair(chip_width - macro[m]->w() / 2, macro[m]->cy()));
			}
		}
	}
	// near bottom
	for(int i = 0; i < v_edge_list[0].size(); i++){
		int m = v_edge_list[0][i].to - 1;
		if(macro[m]->y1() < powerplan_width && macro[m]->y1() != 0 && !macro[m]->is_fixed()){
			if(alpha * macro[m]->y1() < beta * sqrt(macro[m]->y1() * macro[m]->w())){
				macro[m]->updateXY(make_pair(macro[m]->cx(), macro[m]->h() / 2));
			}
		}
	}
	// near top
	for(int i = 0; i < r_v_edge_list[macro.size() + 1].size(); i++){
		int m = r_v_edge_list[macro.size() + 1][i].from - 1;
		if(macro[m]->y2() > (chip_height - powerplan_width) && macro[m]->y2() != chip_height && !macro[m]->is_fixed()){
			if(alpha * macro[m]->y2() < beta * sqrt(macro[m]->y2() * macro[m]->w())){
				macro[m]->updateXY(make_pair(macro[m]->cx(), chip_height - macro[m]->h() / 2));
			}
		}
	}
}

bool cost_tile_cmp(const Tile* a, const Tile* b){
	double a_area = std::abs(a->ti_rt->ti_ll.p_x - a->ti_ll.p_x) * std::abs(a->ti_tr->ti_ll.p_y - a->ti_ll.p_y),
			b_area = std::abs(b->ti_rt->ti_ll.p_x - b->ti_ll.p_x) * std::abs(b->ti_tr->ti_ll.p_y - b->ti_ll.p_y);
	return a_area < b_area;
}

void improve_strategy2(vector<Macro*>& macro, Plane* horizontal_plane, Plane* vertical_plane, Graph& Gh, Graph& Gv){

	vector<edge>* h_edge_list = Gh.get_edge_list();
	vector<edge>* v_edge_list = Gv.get_edge_list();
	vector<edge>* r_h_edge_list = Gh.get_reverse_edge_list();
	vector<edge>* r_v_edge_list = Gv.get_reverse_edge_list();

	vector<Tile*> horizontal_tiles;
	vector<Tile*> vertical_tiles;
	Rect horizontal_region = { {0, 0}, {chip_width, chip_height} };
	Rect vertical_region = {{-chip_height, 0}, {0, chip_width}};	
	// Find out all solid tiles in this subregion
	TiSrArea(NULL, horizontal_plane, &horizontal_region, collectSolidTiles, (ClientData)&horizontal_tiles);
	TiSrArea(NULL, vertical_plane, &vertical_region, collectSolidTiles, (ClientData)&vertical_tiles);

	vector<Tile*> h_cost_tile;
	// Iterative go through solid tiles, calculate macros total area in this subregion, and find out cost tiles
	for(int i = 0; i < horizontal_tiles.size(); i++){
		if(TiGetClient(horizontal_tiles[i]) == -1){
			h_cost_tile.push_back(horizontal_tiles[i]);
		}
	}
	// std::sort(h_cost_tile.begin(), h_cost_tile.end(), cost_tile_cmp);
	std::random_shuffle(h_cost_tile.begin(), h_cost_tile.end());
	vector<Tile*> v_cost_tile;
	for(int i = 0; i < vertical_tiles.size(); i++){
		if(TiGetClient(vertical_tiles[i]) == -1){
			v_cost_tile.push_back(vertical_tiles[i]);
		}
	}
	// std::sort(v_cost_tile.begin(), v_cost_tile.end(), cost_tile_cmp);
	std::random_shuffle(v_cost_tile.begin(), v_cost_tile.end());
	// And adjust edge's weight which connect to these two macros
	if(rand() % 2){
		for(int i = 0; i < h_cost_tile.size(); i++){
			// This cost tile is generated by two macros(left - right)
			if(TiGetBody(BL(h_cost_tile[i])) == SOLID_TILE && TiGetBody(TR(h_cost_tile[i])) == SOLID_TILE &&
				TiGetClient(BL(h_cost_tile[i])) != -1 && TiGetClient(TR(h_cost_tile[i])) != -1){
				// Do not space e(macro, null)
				if(macro[TiGetClient(BL(h_cost_tile[i]))]->name() != "null" && macro[TiGetClient(TR(h_cost_tile[i]))]->name() != "null"){
					// Determine if left macro is the higher one or right macro.
					bool left_higher = macro[TiGetClient(BL(h_cost_tile[i]))]->y1() > macro[TiGetClient(TR(h_cost_tile[i]))]->y1() && 
										macro[TiGetClient(BL(h_cost_tile[i]))]->y2() > macro[TiGetClient(TR(h_cost_tile[i]))]->y2(),
							right_higher = macro[TiGetClient(TR(h_cost_tile[i]))]->y1() > macro[TiGetClient(BL(h_cost_tile[i]))]->y1() && 
										macro[TiGetClient(TR(h_cost_tile[i]))]->y2() > macro[TiGetClient(BL(h_cost_tile[i]))]->y2();
					if(left_higher){
						// Calculate width and height of cost region
						double diff_h = macro[TiGetClient(TR(h_cost_tile[i]))]->x1() - macro[TiGetClient(BL(h_cost_tile[i]))]->x2(),
								diff_v =  macro[TiGetClient(TR(h_cost_tile[i]))]->y2() - macro[TiGetClient(BL(h_cost_tile[i]))]->y1();
						if(alpha * diff_v < beta * sqrt(diff_h * diff_v)){
							// moving macro vertically is supposed to gain benefit
							double left_l = macro[TiGetClient(BL(h_cost_tile[i]))]->x1() - min_spacing,
									left_r = macro[TiGetClient(BL(h_cost_tile[i]))]->x2() + min_spacing,
									left_t = macro[TiGetClient(BL(h_cost_tile[i]))]->y2() + 2 * powerplan_width,
									left_b = macro[TiGetClient(BL(h_cost_tile[i]))]->y2();
							if(left_l < 0) left_l = 0;
							if(left_r > chip_width) left_r = chip_width;
							if(left_t > chip_height) left_t = chip_height;
							double right_l = macro[TiGetClient(TR(h_cost_tile[i]))]->x1() - min_spacing,
									right_r = macro[TiGetClient(TR(h_cost_tile[i]))]->x2() + min_spacing,
									right_t = macro[TiGetClient(TR(h_cost_tile[i]))]->y1(),
									right_b = macro[TiGetClient(TR(h_cost_tile[i]))]->y1() - 2 * powerplan_width;
							if(right_l < 0) right_l = 0;
							if(right_r > chip_width) right_r = chip_width;
							if(right_b < 0) right_b = 0;
							bool left_e = true, right_e = true;
							if(left_t - left_b - diff_v < powerplan_width){
								left_e = false;
							}
							else{
								Rect left_ = { {left_l, left_b}, {left_r, left_t} };
								TiSrArea(NULL, horizontal_plane, &left_, empty_region, (ClientData)&left_e);
							}
							if(right_t - right_b - diff_v < powerplan_width){
								right_e = false;
							}
							else{
								Rect right_ = { {right_l, right_b}, {right_r, right_t} };
								TiSrArea(NULL, horizontal_plane, &right_, empty_region, (ClientData)&right_e);
							}
							if(left_e && !macro[TiGetClient(BL(h_cost_tile[i]))]->is_fixed()){
								// If left macro can move up(left macro is higher)
								macro[TiGetClient(BL(h_cost_tile[i]))]->updateXY(make_pair(macro[TiGetClient(BL(h_cost_tile[i]))]->cx(), macro[TiGetClient(BL(h_cost_tile[i]))]->cy() + diff_v));
								break;
							}
							else if(right_e && !macro[TiGetClient(TR(h_cost_tile[i]))]->is_fixed()){
								// If right macro can move down
								macro[TiGetClient(TR(h_cost_tile[i]))]->updateXY(make_pair(macro[TiGetClient(TR(h_cost_tile[i]))]->cx(), macro[TiGetClient(TR(h_cost_tile[i]))]->cy() - diff_v));
								break;
							}
						}
					}
					else if(right_higher){
						// Calculate width and height of cost region
						double diff_h = macro[TiGetClient(TR(h_cost_tile[i]))]->x1() - macro[TiGetClient(BL(h_cost_tile[i]))]->x2(),
								diff_v =  macro[TiGetClient(BL(h_cost_tile[i]))]->y2() - macro[TiGetClient(TR(h_cost_tile[i]))]->y1();
						if(alpha * diff_v < beta * sqrt(diff_h * diff_v)){
							// moving macro vertically is supposed to gain benefit
							double left_l = macro[TiGetClient(BL(h_cost_tile[i]))]->x1() - min_spacing,
									left_r = macro[TiGetClient(BL(h_cost_tile[i]))]->x2() + min_spacing,
									left_t = macro[TiGetClient(BL(h_cost_tile[i]))]->y1(),
									left_b = macro[TiGetClient(BL(h_cost_tile[i]))]->y1() - 2 * powerplan_width;
							if(left_l < 0) left_l = 0;
							if(left_r > chip_width) left_r = chip_width;
							if(left_b < 0) left_b = 0;
							double right_l = macro[TiGetClient(TR(h_cost_tile[i]))]->x1() - min_spacing,
									right_r = macro[TiGetClient(TR(h_cost_tile[i]))]->x2() + min_spacing,
									right_t = macro[TiGetClient(TR(h_cost_tile[i]))]->y2() + 2 * powerplan_width,
									right_b = macro[TiGetClient(TR(h_cost_tile[i]))]->y2();
							if(right_l < 0) right_l = 0;
							if(right_r > chip_width) right_r = chip_width;
							if(right_t > chip_height) right_t = chip_height;
							bool left_e = true, right_e = true;
							if(left_t - left_b - diff_v < powerplan_width){
								left_e = false;
							}
							else{
								Rect left_ = { {left_l, left_b}, {left_r, left_t} };
								TiSrArea(NULL, horizontal_plane, &left_, empty_region, (ClientData)&left_e);
							}
							if(right_t - right_b - diff_v < powerplan_width){
								right_e = false;
							}
							else{
								Rect right_ = { {right_l, right_b}, {right_r, right_t} };
								TiSrArea(NULL, horizontal_plane, &right_, empty_region, (ClientData)&right_e);
							}
							if(left_e && !macro[TiGetClient(BL(h_cost_tile[i]))]->is_fixed()){
								// If left macro can move down(left macro is higher)
								macro[TiGetClient(BL(h_cost_tile[i]))]->updateXY(make_pair(macro[TiGetClient(BL(h_cost_tile[i]))]->cx(), macro[TiGetClient(BL(h_cost_tile[i]))]->cy() - diff_v));
								break;
							}
							else if(right_e && !macro[TiGetClient(TR(h_cost_tile[i]))]->is_fixed()){
								// If right macro can move up(right macro is higher)
								macro[TiGetClient(TR(h_cost_tile[i]))]->updateXY(make_pair(macro[TiGetClient(TR(h_cost_tile[i]))]->cx(), macro[TiGetClient(TR(h_cost_tile[i]))]->cy() + diff_v));
								break;
							}
						}
					}
					// moving macros vertically can't get good benefit, we try to seperate two macros horizontally
					for(int j = 0; j < h_edge_list[TiGetClient(BL(h_cost_tile[i])) + 1].size(); j++){
						if(h_edge_list[TiGetClient(BL(h_cost_tile[i])) + 1][j].to - 1 == TiGetClient(TR(h_cost_tile[i]))){
							h_edge_list[TiGetClient(BL(h_cost_tile[i])) + 1][j].weight = (macro[TiGetClient(BL(h_cost_tile[i]))]->w() + macro[TiGetClient(TR(h_cost_tile[i]))]->w()) / 2 + powerplan_width;
						}
					}
					for(int j = 0; j < r_h_edge_list[TiGetClient(TR(h_cost_tile[i])) + 1].size(); j++){
						if(r_h_edge_list[TiGetClient(TR(h_cost_tile[i])) + 1][j].from - 1 == TiGetClient(BL(h_cost_tile[i]))){
							r_h_edge_list[TiGetClient(TR(h_cost_tile[i])) + 1][j].weight = (macro[TiGetClient(BL(h_cost_tile[i]))]->w() + macro[TiGetClient(TR(h_cost_tile[i]))]->w()) / 2 + powerplan_width;
						}
					}
					break;
				}
			}
		}
	}
	else{
		for(int i = 0; i < v_cost_tile.size(); i++){
			// This cost tile is generated by two macros(left - right)
			if(TiGetBody(BL(v_cost_tile[i])) == SOLID_TILE && TiGetBody(TR(v_cost_tile[i])) == SOLID_TILE &&
				TiGetClient(BL(v_cost_tile[i])) != -1 && TiGetClient(TR(v_cost_tile[i])) != -1){
				// Do not space e(macro, null)
				if(macro[TiGetClient(BL(v_cost_tile[i]))]->name() != "null" && macro[TiGetClient(TR(v_cost_tile[i]))]->name() != "null"){
					// Determine if top macro more close to right hand side one or bottom macro.
					bool bottom_at_right = macro[TiGetClient(TR(v_cost_tile[i]))]->x1() > macro[TiGetClient(BL(v_cost_tile[i]))]->x1() && 
										macro[TiGetClient(TR(v_cost_tile[i]))]->x2() > macro[TiGetClient(BL(v_cost_tile[i]))]->x2(),
							top_at_right = macro[TiGetClient(BL(v_cost_tile[i]))]->x1() > macro[TiGetClient(TR(v_cost_tile[i]))]->x1() && 
										macro[TiGetClient(BL(v_cost_tile[i]))]->x2() > macro[TiGetClient(TR(v_cost_tile[i]))]->x2();

					if(bottom_at_right){
						// Calculate width and height of cost region
						double diff_h = macro[TiGetClient(BL(v_cost_tile[i]))]->x2() - macro[TiGetClient(TR(v_cost_tile[i]))]->x1(),
								diff_v =  macro[TiGetClient(BL(v_cost_tile[i]))]->y1() - macro[TiGetClient(TR(v_cost_tile[i]))]->y2();
						if(alpha * diff_h < beta * sqrt(diff_h * diff_v)){
							// moving macro horizontally is supposed to gain benefit
							double bottom_l = macro[TiGetClient(TR(v_cost_tile[i]))]->x2(),
									bottom_r = macro[TiGetClient(TR(v_cost_tile[i]))]->x2() + 2 * powerplan_width,
									bottom_t = macro[TiGetClient(TR(v_cost_tile[i]))]->y2() + min_spacing,
									bottom_b = macro[TiGetClient(TR(v_cost_tile[i]))]->y1() - min_spacing;
							if(bottom_r > chip_width) bottom_r = chip_width;
							if(bottom_b < 0) bottom_b = 0;
							if(bottom_t > chip_height) bottom_t = chip_height;
							double top_l = macro[TiGetClient(BL(v_cost_tile[i]))]->x1() - 2 * powerplan_width,
									top_r = macro[TiGetClient(BL(v_cost_tile[i]))]->x1(),
									top_t = macro[TiGetClient(BL(v_cost_tile[i]))]->y2() + min_spacing,
									top_b = macro[TiGetClient(BL(v_cost_tile[i]))]->y1() - min_spacing;
							if(top_l < 0) top_l = 0;
							if(top_b < 0) top_b = 0;
							if(top_t > chip_height) top_t = chip_height;
							bool bottom_e = true, top_e = true;
							if(bottom_r - bottom_l - diff_h < powerplan_width){
								bottom_e = false;
							}
							else{
								Rect bottom_ = { {bottom_l, bottom_b}, {bottom_r, bottom_t} };
								TiSrArea(NULL, vertical_plane, &bottom_, empty_region, (ClientData)&bottom_e);
							}
							if(top_r - top_l - diff_h < powerplan_width){
								top_e = false;
							}
							else{
								Rect top_ = { {top_l, top_b}, {top_r, top_t} };
								TiSrArea(NULL, vertical_plane, &top_, empty_region, (ClientData)&top_e);
							}
							if(bottom_e && !macro[TiGetClient(TR(v_cost_tile[i]))]->is_fixed()){
								// If bottom macro can move right(bottom macro is more close to right hand side)
								macro[TiGetClient(TR(v_cost_tile[i]))]->updateXY(make_pair(macro[TiGetClient(TR(v_cost_tile[i]))]->cx() + diff_h, macro[TiGetClient(TR(v_cost_tile[i]))]->cy()));
								break;
							}
							else if(top_e && !macro[TiGetClient(BL(v_cost_tile[i]))]->is_fixed()){
								// If top macro can move left
								macro[TiGetClient(BL(v_cost_tile[i]))]->updateXY(make_pair(macro[TiGetClient(BL(v_cost_tile[i]))]->cx() - diff_h, macro[TiGetClient(BL(v_cost_tile[i]))]->cy()));
								break;
							}
						}
					}
					else if(top_at_right){
						// Calculate width and height of cost region
						double diff_h = macro[TiGetClient(TR(v_cost_tile[i]))]->x2() - macro[TiGetClient(BL(v_cost_tile[i]))]->x1(),
								diff_v =  macro[TiGetClient(BL(v_cost_tile[i]))]->y1() - macro[TiGetClient(TR(v_cost_tile[i]))]->y2();
						if(alpha * diff_h < beta * sqrt(diff_h * diff_v)){
							// moving macro horizontally is supposed to gain benefit
							double bottom_l = macro[TiGetClient(TR(v_cost_tile[i]))]->x1() - 2 * powerplan_width,
									bottom_r = macro[TiGetClient(TR(v_cost_tile[i]))]->x1(),
									bottom_t = macro[TiGetClient(TR(v_cost_tile[i]))]->y2() + min_spacing,
									bottom_b = macro[TiGetClient(TR(v_cost_tile[i]))]->y1() - min_spacing;
							if(bottom_l < 0) bottom_l = 0;
							if(bottom_b < 0) bottom_b = 0;
							if(bottom_t > chip_height) bottom_t = chip_height;
							double top_l = macro[TiGetClient(BL(v_cost_tile[i]))]->x2(),
									top_r = macro[TiGetClient(BL(v_cost_tile[i]))]->x2() + 2 * powerplan_width,
									top_t = macro[TiGetClient(BL(v_cost_tile[i]))]->y2() + min_spacing,
									top_b = macro[TiGetClient(BL(v_cost_tile[i]))]->y1() - min_spacing;
							if(top_r > chip_width) top_r = chip_width;
							if(top_b < 0) top_b = 0;
							if(top_t > chip_height) top_t = chip_height;
							bool bottom_e = true, top_e = true;
							if(bottom_r - bottom_l - diff_h < powerplan_width){
								bottom_e = false;
							}
							else{
								Rect bottom_ = { {bottom_l, bottom_b}, {bottom_r, bottom_t} };
								TiSrArea(NULL, vertical_plane, &bottom_, empty_region, (ClientData)&bottom_e);
							}
							if(top_r - top_l - diff_h < powerplan_width){
								top_e = false;
							}
							else{
								Rect top_ = { {top_l, top_b}, {top_r, top_t} };
								TiSrArea(NULL, vertical_plane, &top_, empty_region, (ClientData)&top_e);
							}
							if(bottom_e && !macro[TiGetClient(TR(v_cost_tile[i]))]->is_fixed()){
								// If bottom macro can move left(bottom macro is more close to left hand side)
								macro[TiGetClient(TR(v_cost_tile[i]))]->updateXY(make_pair(macro[TiGetClient(TR(v_cost_tile[i]))]->cx() - diff_h, macro[TiGetClient(TR(v_cost_tile[i]))]->cy()));
								break;
							}
							else if(top_e && !macro[TiGetClient(BL(v_cost_tile[i]))]->is_fixed()){
								// If top macro can move right
								macro[TiGetClient(BL(v_cost_tile[i]))]->updateXY(make_pair(macro[TiGetClient(BL(v_cost_tile[i]))]->cx() + diff_h, macro[TiGetClient(BL(v_cost_tile[i]))]->cy()));
								break;
							}
						}
					}
					// moving macros horizontally can't get good benefit, we try to seperate two macros vertically
					for(int j = 0; j < v_edge_list[TiGetClient(TR(v_cost_tile[i])) + 1].size(); j++){
						if(v_edge_list[TiGetClient(TR(v_cost_tile[i])) + 1][j].to - 1 == TiGetClient(BL(v_cost_tile[i]))){
							v_edge_list[TiGetClient(TR(v_cost_tile[i])) + 1][j].weight = (macro[TiGetClient(TR(v_cost_tile[i]))]->h() + macro[TiGetClient(BL(v_cost_tile[i]))]->h()) / 2 + powerplan_width;
						}
					}
					for(int j = 0; j < r_v_edge_list[TiGetClient(BL(v_cost_tile[i])) + 1].size(); j++){
						if(r_v_edge_list[TiGetClient(BL(v_cost_tile[i])) + 1][j].from - 1 == TiGetClient(TR(v_cost_tile[i]))){
							r_v_edge_list[TiGetClient(BL(v_cost_tile[i])) + 1][j].weight = (macro[TiGetClient(TR(v_cost_tile[i]))]->h() + macro[TiGetClient(BL(v_cost_tile[i]))]->h()) / 2 + powerplan_width;
						}
					}
					break;
				}
			}
		}
	}
	// Updates zero slack edges
	while(Gh.longest_path(true) > chip_width){
		vector<edge*> h_zero_slack;
		h_zero_slack = Gh.zero_slack();
		for(int i = 0; i < h_zero_slack.size(); i++){
			// restore some of edges in critical path instead of restoring all.
			if(rand() % 5)
				continue;
			if(h_zero_slack[i]->from == 0){
				if(h_zero_slack[i]->weight == macro[h_zero_slack[i]->to - 1]->w() / 2 + powerplan_width){
					h_zero_slack[i]->weight = macro[h_zero_slack[i]->to - 1]->w() / 2;
				}
			}			
			if(h_zero_slack[i]->from != 0 && h_zero_slack[i]->to != macro.size() + 1){
				if(h_zero_slack[i]->weight == (macro[h_zero_slack[i]->from - 1]->w() + macro[h_zero_slack[i]->to - 1]->w()) / 2 + powerplan_width){
					h_zero_slack[i]->weight = (macro[h_zero_slack[i]->from - 1]->w() + macro[h_zero_slack[i]->to - 1]->w()) / 2 + min_spacing;
					// Also set reverse constraint graph
					for(int j = 0; j < r_h_edge_list[h_zero_slack[i]->to].size(); j++){
						if(r_h_edge_list[h_zero_slack[i]->to][j].from == h_zero_slack[i]->from)
							r_h_edge_list[h_zero_slack[i]->to][j].weight = (macro[h_zero_slack[i]->from - 1]->w() + macro[h_zero_slack[i]->to - 1]->w()) / 2 + min_spacing;
					}
				}
				if(h_zero_slack[i]->weight == (macro[h_zero_slack[i]->from - 1]->w() + macro[h_zero_slack[i]->to - 1]->w()) / 2 &&
					macro[h_zero_slack[i]->from - 1]->name() != "null" && macro[h_zero_slack[i]->to - 1]->name() != "null"){
					Gh.remove_edge(h_zero_slack[i]->from, h_zero_slack[i]->to);
				}
			}
		}
	}
	while(Gv.longest_path(false) > chip_height){
		vector<edge*> v_zero_slack;
		v_zero_slack = Gv.zero_slack();
		for(int i = 0; i < v_zero_slack.size(); i++){
			// restore some of edges in critical path instead of restoring all.
			if(rand() % 5)
				continue;
			if(v_zero_slack[i]->from == 0){
				if(v_zero_slack[i]->weight == macro[v_zero_slack[i]->to - 1]->h() / 2 + powerplan_width){
					v_zero_slack[i]->weight = macro[v_zero_slack[i]->to - 1]->h() / 2;
				}
			}
			if(v_zero_slack[i]->from != 0 && v_zero_slack[i]->to != macro.size() + 1){
				if(v_zero_slack[i]->weight == (macro[v_zero_slack[i]->from - 1]->h() + macro[v_zero_slack[i]->to - 1]->h()) / 2 + powerplan_width){
					v_zero_slack[i]->weight = (macro[v_zero_slack[i]->from - 1]->h() + macro[v_zero_slack[i]->to - 1]->h()) / 2 + min_spacing;
					// Also set reverse constraint graph
					for(int j = 0; j < r_v_edge_list[v_zero_slack[i]->to].size(); j++){
						if(r_v_edge_list[v_zero_slack[i]->to][j].from == v_zero_slack[i]->from)
							r_v_edge_list[v_zero_slack[i]->to][j].weight = (macro[v_zero_slack[i]->from - 1]->h() + macro[v_zero_slack[i]->to - 1]->h()) / 2 + min_spacing;
					}					
				}
				if(v_zero_slack[i]->weight == (macro[v_zero_slack[i]->from - 1]->h() + macro[v_zero_slack[i]->to - 1]->h()) / 2 &&
					macro[v_zero_slack[i]->from - 1]->name() != "null" && macro[v_zero_slack[i]->to - 1]->name() != "null"){
					Gv.remove_edge(v_zero_slack[i]->from, v_zero_slack[i]->to);
				}
			}
		}
	}
}


//=========TODO========
//check what kind of edges' weight maybe changed. ex. source->null, source->fixed, placed->placed
//all of changes should can be change to initial value if the edge involve in critical path

void improve_strategy3(vector<Macro*>& macro, Plane* horizontal_plane, Plane* vertical_plane){

	vector<Tile*> horizontal_tiles;
	vector<Tile*> vertical_tiles;

	Rect horizontal_region = { {0, 0}, {chip_width, chip_height} };
	Rect vertical_region = {{-chip_height, 0}, {0, chip_width}};	
	
	TiSrArea(NULL, horizontal_plane, &horizontal_region, collectSolidTiles, (ClientData)&horizontal_tiles);
	TiSrArea(NULL, vertical_plane, &vertical_region, collectSolidTiles, (ClientData)&vertical_tiles);
	vector<Tile*> h_cost_tile;
	// Iterative go through solid tiles find out cost tiles
	for(int i = 0; i < horizontal_tiles.size(); i++){
		if(TiGetClient(horizontal_tiles[i]) == -1)
			h_cost_tile.push_back(horizontal_tiles[i]);
	}
	// std::sort(h_cost_tile.begin(), h_cost_tile.end(), cost_tile_cmp);
	std::random_shuffle(h_cost_tile.begin(), h_cost_tile.end());
	vector<Tile*> v_cost_tile;
	for(int i = 0; i < vertical_tiles.size(); i++){
		if(TiGetClient(vertical_tiles[i]) == -1)
			v_cost_tile.push_back(vertical_tiles[i]);
	}
	// std::sort(v_cost_tile.begin(), v_cost_tile.end(), cost_tile_cmp);
	std::random_shuffle(v_cost_tile.begin(), v_cost_tile.end());

	bool change_hcg = false, change_vcg = false;

	if(rand() % 2){
		for(int i = 0; i < h_cost_tile.size(); i++){
			// This cost tile is generated by two macros(left - right)
			if(TiGetBody(BL(h_cost_tile[i])) == SOLID_TILE && TiGetBody(TR(h_cost_tile[i])) == SOLID_TILE &&
				TiGetClient(BL(h_cost_tile[i])) != -1 && TiGetClient(TR(h_cost_tile[i])) != -1){
				// Do not space e(macro, null)
				if(macro[TiGetClient(BL(h_cost_tile[i]))]->name() != "null" && macro[TiGetClient(TR(h_cost_tile[i]))]->name() != "null"){
					double left_left = macro[TiGetClient(BL(h_cost_tile[i]))]->x1() - 2 * powerplan_width,
							left_right = macro[TiGetClient(BL(h_cost_tile[i]))]->x1(),
							left_top = macro[TiGetClient(BL(h_cost_tile[i]))]->y2() + min_spacing,
							left_bottom = macro[TiGetClient(BL(h_cost_tile[i]))]->y1() - min_spacing;
					if(left_left < 0) left_left = 0;
					if(left_top > chip_height) left_top = chip_height;
					if(left_bottom < 0) left_bottom = 0;
					double right_left = macro[TiGetClient(TR(h_cost_tile[i]))]->x2(),
							right_right = macro[TiGetClient(TR(h_cost_tile[i]))]->x2() + 2 * powerplan_width,
							right_top = macro[TiGetClient(TR(h_cost_tile[i]))]->y2() + min_spacing,
							right_bottom = macro[TiGetClient(TR(h_cost_tile[i]))]->y1() - min_spacing;
					if(right_right > chip_width) right_right = chip_width;
					if(right_top > chip_height) right_top = chip_height;
					if(right_bottom < 0) right_bottom = 0;
					bool left_empty = true, right_empty = true;
					if(left_right - left_left < powerplan_width){
						left_empty = false;
						if(alpha * (left_right - left_left) < beta * sqrt((left_right - left_left) * macro[TiGetClient(BL(h_cost_tile[i]))]->h())
							&& !macro[TiGetClient(BL(h_cost_tile[i]))]->is_fixed()){
							macro[TiGetClient(BL(h_cost_tile[i]))]->updateXY(make_pair(macro[TiGetClient(BL(h_cost_tile[i]))]->w() / 2, macro[TiGetClient(BL(h_cost_tile[i]))]->cy()));
						}
					}
					else{
						Rect left = { {left_left, left_bottom}, {left_right, left_top} };
						TiSrArea(NULL, horizontal_plane, &left, empty_region, (ClientData)&left_empty);
					}
					if(right_right - right_left < powerplan_width){
						right_empty = false;
						if(alpha * (right_right - right_left) < beta * sqrt((right_right - right_left) * macro[TiGetClient(TR(h_cost_tile[i]))]->h())
							&& !macro[TiGetClient(TR(h_cost_tile[i]))]->is_fixed()){
							macro[TiGetClient(TR(h_cost_tile[i]))]->updateXY(make_pair(chip_width - macro[TiGetClient(TR(h_cost_tile[i]))]->w() / 2, macro[TiGetClient(TR(h_cost_tile[i]))]->cy()));
						}
					}
					else{
						Rect right = { {right_left, right_bottom}, {right_right, right_top} };
						TiSrArea(NULL, horizontal_plane, &right, empty_region, (ClientData)&right_empty);
					}

					bool left_higher = macro[TiGetClient(BL(h_cost_tile[i]))]->y1() > macro[TiGetClient(TR(h_cost_tile[i]))]->y1() && 
										macro[TiGetClient(BL(h_cost_tile[i]))]->y2() > macro[TiGetClient(TR(h_cost_tile[i]))]->y2(),
							right_higher = macro[TiGetClient(TR(h_cost_tile[i]))]->y1() > macro[TiGetClient(BL(h_cost_tile[i]))]->y1() && 
										macro[TiGetClient(TR(h_cost_tile[i]))]->y2() > macro[TiGetClient(BL(h_cost_tile[i]))]->y2();

					double diff_h = macro[TiGetClient(TR(h_cost_tile[i]))]->x1() - macro[TiGetClient(BL(h_cost_tile[i]))]->x2();
					
					if(diff_h >= powerplan_width){
						continue;
					}

					if(left_higher){
						double diff_v =  macro[TiGetClient(TR(h_cost_tile[i]))]->y2() - macro[TiGetClient(BL(h_cost_tile[i]))]->y1();
						if(powerplan_width - diff_h < diff_v){
							if(alpha * (powerplan_width - diff_h) < beta * sqrt(diff_h * diff_v)){
								if(left_empty && !macro[TiGetClient(BL(h_cost_tile[i]))]->is_fixed()){
									macro[TiGetClient(BL(h_cost_tile[i]))]->updateXY(make_pair(macro[TiGetClient(BL(h_cost_tile[i]))]->cx() - (powerplan_width - diff_h), macro[TiGetClient(BL(h_cost_tile[i]))]->cy()));
									break;
								}
								else if(right_empty && !macro[TiGetClient(TR(h_cost_tile[i]))]->is_fixed()){
									macro[TiGetClient(TR(h_cost_tile[i]))]->updateXY(make_pair(macro[TiGetClient(TR(h_cost_tile[i]))]->cx() + (powerplan_width - diff_h), macro[TiGetClient(TR(h_cost_tile[i]))]->cy()));
									break;
								}
							}
						}
						else{
							if(alpha * diff_v < beta * sqrt(diff_h * diff_v)){
								double left_l = macro[TiGetClient(BL(h_cost_tile[i]))]->x1() - min_spacing,
										left_r = macro[TiGetClient(BL(h_cost_tile[i]))]->x2() + min_spacing,
										left_t = macro[TiGetClient(BL(h_cost_tile[i]))]->y2() + 2 * powerplan_width,
										left_b = macro[TiGetClient(BL(h_cost_tile[i]))]->y2();
								if(left_l < 0) left_l = 0;
								if(left_r > chip_width) left_r = chip_width;
								if(left_t > chip_height) left_t = chip_height;
								double right_l = macro[TiGetClient(TR(h_cost_tile[i]))]->x1() - min_spacing,
										right_r = macro[TiGetClient(TR(h_cost_tile[i]))]->x2() + min_spacing,
										right_t = macro[TiGetClient(TR(h_cost_tile[i]))]->y1(),
										right_b = macro[TiGetClient(TR(h_cost_tile[i]))]->y1() - 2 * powerplan_width;
								if(right_l < 0) right_l = 0;
								if(right_r > chip_width) right_r = chip_width;
								if(right_b < 0) right_b = 0;
								bool left_e = true, right_e = true;
								if(left_t - left_b - diff_v < powerplan_width){
									left_e = false;
								}
								else{
									Rect left_ = { {left_l, left_b}, {left_r, left_t} };
									TiSrArea(NULL, horizontal_plane, &left_, empty_region, (ClientData)&left_e);
								}
								if(right_t - right_b - diff_v < powerplan_width){
									right_e = false;
								}
								else{
									Rect right_ = { {right_l, right_b}, {right_r, right_t} };
									TiSrArea(NULL, horizontal_plane, &right_, empty_region, (ClientData)&right_e);
								}
								if(left_e && !macro[TiGetClient(BL(h_cost_tile[i]))]->is_fixed()){
									macro[TiGetClient(BL(h_cost_tile[i]))]->updateXY(make_pair(macro[TiGetClient(BL(h_cost_tile[i]))]->cx(), macro[TiGetClient(BL(h_cost_tile[i]))]->cy() + diff_v));
									break;
								}
								else if(right_e && !macro[TiGetClient(TR(h_cost_tile[i]))]->is_fixed()){
									macro[TiGetClient(TR(h_cost_tile[i]))]->updateXY(make_pair(macro[TiGetClient(TR(h_cost_tile[i]))]->cx(), macro[TiGetClient(TR(h_cost_tile[i]))]->cy() - diff_v));
									break;
								}
							}
						}
					}
					else if(right_higher){
						double diff_v =  macro[TiGetClient(BL(h_cost_tile[i]))]->y2() - macro[TiGetClient(TR(h_cost_tile[i]))]->y1();
						if(powerplan_width - diff_h < diff_v){
							if(alpha * (powerplan_width - diff_h) < beta * sqrt(diff_h * diff_v)){
								if(left_empty && !macro[TiGetClient(BL(h_cost_tile[i]))]->is_fixed()){
									macro[TiGetClient(BL(h_cost_tile[i]))]->updateXY(make_pair(macro[TiGetClient(BL(h_cost_tile[i]))]->cx() - (powerplan_width - diff_h), macro[TiGetClient(BL(h_cost_tile[i]))]->cy()));
									break;
								}
								else if(right_empty && !macro[TiGetClient(TR(h_cost_tile[i]))]->is_fixed()){
									macro[TiGetClient(TR(h_cost_tile[i]))]->updateXY(make_pair(macro[TiGetClient(TR(h_cost_tile[i]))]->cx() + (powerplan_width - diff_h), macro[TiGetClient(TR(h_cost_tile[i]))]->cy()));
									break;
								}
							}
						}
						else{
							if(alpha * diff_v < beta * sqrt(diff_h * diff_v)){
								double left_l = macro[TiGetClient(BL(h_cost_tile[i]))]->x1() - min_spacing,
										left_r = macro[TiGetClient(BL(h_cost_tile[i]))]->x2() + min_spacing,
										left_t = macro[TiGetClient(BL(h_cost_tile[i]))]->y1(),
										left_b = macro[TiGetClient(BL(h_cost_tile[i]))]->y1() - 2 * powerplan_width;
								if(left_l < 0) left_l = 0;
								if(left_r > chip_width) left_r = chip_width;
								if(left_b < 0) left_b = 0;
								double right_l = macro[TiGetClient(TR(h_cost_tile[i]))]->x1() - min_spacing,
										right_r = macro[TiGetClient(TR(h_cost_tile[i]))]->x2() + min_spacing,
										right_t = macro[TiGetClient(TR(h_cost_tile[i]))]->y2() + 2 * powerplan_width,
										right_b = macro[TiGetClient(TR(h_cost_tile[i]))]->y2();
								if(right_l < 0) right_l = 0;
								if(right_r > chip_width) right_r = chip_width;
								if(right_t > chip_height) right_t = chip_height;
								bool left_e = true, right_e = true;
								if(left_t - left_b - diff_v < powerplan_width){
									left_e = false;
								}
								else{
									Rect left_ = { {left_l, left_b}, {left_r, left_t} };
									TiSrArea(NULL, horizontal_plane, &left_, empty_region, (ClientData)&left_e);
								}
								if(right_t - right_b - diff_v < powerplan_width){
									right_e = false;
								}
								else{
									Rect right_ = { {right_l, right_b}, {right_r, right_t} };
									TiSrArea(NULL, horizontal_plane, &right_, empty_region, (ClientData)&right_e);
								}
								if(left_e && !macro[TiGetClient(BL(h_cost_tile[i]))]->is_fixed()){
									macro[TiGetClient(BL(h_cost_tile[i]))]->updateXY(make_pair(macro[TiGetClient(BL(h_cost_tile[i]))]->cx(), macro[TiGetClient(BL(h_cost_tile[i]))]->cy() - diff_v));
									break;
								}
								else if(right_e && !macro[TiGetClient(TR(h_cost_tile[i]))]->is_fixed()){
									macro[TiGetClient(TR(h_cost_tile[i]))]->updateXY(make_pair(macro[TiGetClient(TR(h_cost_tile[i]))]->cx(), macro[TiGetClient(TR(h_cost_tile[i]))]->cy() + diff_v));
									break;
								}
							}
						}
					}
				}
			}
		}
	}
	else{
		for(int i = 0; i < v_cost_tile.size(); i++){
			// This cost tile is generated by two macro(top - bottom)
			if(TiGetBody(BL(v_cost_tile[i])) == SOLID_TILE && TiGetBody(TR(v_cost_tile[i])) == SOLID_TILE &&
				TiGetClient(BL(v_cost_tile[i])) != -1 && TiGetClient(TR(v_cost_tile[i])) != -1){
				// Do not space e(macro, null)
				if(macro[TiGetClient(BL(v_cost_tile[i]))]->name() != "null" && macro[TiGetClient(TR(v_cost_tile[i]))]->name() != "null"){
					
					double bottom_left = macro[TiGetClient(TR(v_cost_tile[i]))]->x1() - min_spacing,
							bottom_right = macro[TiGetClient(TR(v_cost_tile[i]))]->x2() + min_spacing,
							bottom_top = macro[TiGetClient(TR(v_cost_tile[i]))]->y1(),
							bottom_bottom = macro[TiGetClient(TR(v_cost_tile[i]))]->y1() - 2 * powerplan_width;
					if(bottom_bottom < 0) bottom_bottom = 0;
					if(bottom_left < 0) bottom_left = 0;
					if(bottom_right > chip_width) bottom_right = chip_width;
					double top_left = macro[TiGetClient(BL(v_cost_tile[i]))]->x1() - min_spacing,
							top_right = macro[TiGetClient(BL(v_cost_tile[i]))]->x2() + min_spacing,
							top_top = macro[TiGetClient(BL(v_cost_tile[i]))]->y2() + 2 * powerplan_width,
							top_bottom = macro[TiGetClient(BL(v_cost_tile[i]))]->y2();
					if(top_top > chip_height) top_top = chip_height;
					if(top_left < 0) top_left = 0;
					if(top_right > chip_width) top_right = chip_width;

					bool bottom_empty = true, top_empty = true;
					if(bottom_top - bottom_bottom < powerplan_width){
						bottom_empty = false;
						if(alpha * (bottom_top - bottom_bottom) < beta * sqrt((bottom_top - bottom_bottom) * macro[TiGetClient(TR(v_cost_tile[i]))]->w())
							&& !macro[TiGetClient(TR(v_cost_tile[i]))]->is_fixed()){
							macro[TiGetClient(TR(v_cost_tile[i]))]->updateXY(make_pair(macro[TiGetClient(TR(v_cost_tile[i]))]->cx(), macro[TiGetClient(TR(v_cost_tile[i]))]->h() / 2));
						}
					}
					else{
						Rect bottom = { {-bottom_top, bottom_left}, {-bottom_bottom, bottom_right} };
						TiSrArea(NULL, vertical_plane, &bottom, empty_region, (ClientData)&bottom_empty);
					}
					if(top_top - top_bottom < powerplan_width){
						top_empty = false;
						if(alpha * (top_top - top_bottom) < beta * sqrt((top_top - top_bottom) * macro[TiGetClient(BL(v_cost_tile[i]))]->w())
							&& !macro[TiGetClient(BL(v_cost_tile[i]))]->is_fixed()){
							macro[TiGetClient(BL(v_cost_tile[i]))]->updateXY(make_pair(macro[TiGetClient(BL(v_cost_tile[i]))]->cx(), chip_height - macro[TiGetClient(BL(v_cost_tile[i]))]->h() / 2));
						}
					}
					else{
						Rect top = { {-top_top, top_left}, {-top_bottom, top_right} };
						TiSrArea(NULL, vertical_plane, &top, empty_region, (ClientData)&top_empty);
					}

					bool bottom_at_right = macro[TiGetClient(TR(v_cost_tile[i]))]->x1() > macro[TiGetClient(BL(v_cost_tile[i]))]->x1() && 
										macro[TiGetClient(TR(v_cost_tile[i]))]->x2() > macro[TiGetClient(BL(v_cost_tile[i]))]->x2(),
							top_at_right = macro[TiGetClient(BL(v_cost_tile[i]))]->x1() > macro[TiGetClient(TR(v_cost_tile[i]))]->x1() && 
										macro[TiGetClient(BL(v_cost_tile[i]))]->x2() > macro[TiGetClient(TR(v_cost_tile[i]))]->x2();

					double diff_v =  macro[TiGetClient(BL(v_cost_tile[i]))]->y1() - macro[TiGetClient(TR(v_cost_tile[i]))]->y2();

					if(diff_v >= powerplan_width){
						continue;
					}

					if(bottom_at_right){
						double diff_h = macro[TiGetClient(BL(v_cost_tile[i]))]->x2() - macro[TiGetClient(TR(v_cost_tile[i]))]->x1();
						if(powerplan_width - diff_v < diff_h){
							if(alpha * (powerplan_width - diff_v) < beta * sqrt(diff_h * diff_v)){
								if(top_empty && !macro[TiGetClient(BL(v_cost_tile[i]))]->is_fixed()){
									macro[TiGetClient(BL(v_cost_tile[i]))]->updateXY(make_pair(macro[TiGetClient(BL(v_cost_tile[i]))]->cx(), macro[TiGetClient(BL(v_cost_tile[i]))]->cy() + (powerplan_width - diff_v)));
									break;
								}
								else if(bottom_empty && !macro[TiGetClient(TR(v_cost_tile[i]))]->is_fixed()){
									macro[TiGetClient(TR(v_cost_tile[i]))]->updateXY(make_pair(macro[TiGetClient(TR(v_cost_tile[i]))]->cx(), macro[TiGetClient(TR(v_cost_tile[i]))]->cy() - (powerplan_width - diff_v)));
									break;
								}
							}
						}
						else{
							if(alpha * diff_h < beta * sqrt(diff_h * diff_v)){
								double bottom_l = macro[TiGetClient(TR(v_cost_tile[i]))]->x2(),
										bottom_r = macro[TiGetClient(TR(v_cost_tile[i]))]->x2() + 2 * powerplan_width,
										bottom_t = macro[TiGetClient(TR(v_cost_tile[i]))]->y2() + min_spacing,
										bottom_b = macro[TiGetClient(TR(v_cost_tile[i]))]->y1() - min_spacing;
								if(bottom_r > chip_width) bottom_r = chip_width;
								if(bottom_b < 0) bottom_b = 0;
								if(bottom_t > chip_height) bottom_t = chip_height;
								double top_l = macro[TiGetClient(BL(v_cost_tile[i]))]->x1() - 2 * powerplan_width,
										top_r = macro[TiGetClient(BL(v_cost_tile[i]))]->x1(),
										top_t = macro[TiGetClient(BL(v_cost_tile[i]))]->y2() + min_spacing,
										top_b = macro[TiGetClient(BL(v_cost_tile[i]))]->y1() - min_spacing;
								if(top_l < 0) top_l = 0;
								if(top_b < 0) top_b = 0;
								if(top_t > chip_height) top_t = chip_height;
								bool bottom_e = true, top_e = true;
								if(bottom_r - bottom_l - diff_h < powerplan_width){
									bottom_e = false;
								}
								else{
									Rect bottom_ = { {bottom_l, bottom_b}, {bottom_r, bottom_t} };
									TiSrArea(NULL, vertical_plane, &bottom_, empty_region, (ClientData)&bottom_e);
								}
								if(top_r - top_l - diff_h < powerplan_width){
									top_e = false;
								}
								else{
									Rect top_ = { {top_l, top_b}, {top_r, top_t} };
									TiSrArea(NULL, vertical_plane, &top_, empty_region, (ClientData)&top_e);
								}
								if(bottom_e && !macro[TiGetClient(TR(v_cost_tile[i]))]->is_fixed()){
									macro[TiGetClient(TR(v_cost_tile[i]))]->updateXY(make_pair(macro[TiGetClient(TR(v_cost_tile[i]))]->cx() + diff_h, macro[TiGetClient(TR(v_cost_tile[i]))]->cy()));
									break;
								}
								else if(top_e && !macro[TiGetClient(BL(v_cost_tile[i]))]->is_fixed()){
									macro[TiGetClient(BL(v_cost_tile[i]))]->updateXY(make_pair(macro[TiGetClient(BL(v_cost_tile[i]))]->cx() - diff_h, macro[TiGetClient(BL(v_cost_tile[i]))]->cy()));
									break;
								}
							}
						}
					}
					else if(top_at_right){
						double diff_h = macro[TiGetClient(TR(v_cost_tile[i]))]->x2() - macro[TiGetClient(BL(v_cost_tile[i]))]->x1();
						if(powerplan_width - diff_v < diff_h){
							if(alpha * (powerplan_width - diff_v) < beta * sqrt(diff_h * diff_v)){
								if(top_empty && !macro[TiGetClient(BL(v_cost_tile[i]))]->is_fixed()){
									macro[TiGetClient(BL(v_cost_tile[i]))]->updateXY(make_pair(macro[TiGetClient(BL(v_cost_tile[i]))]->cx(), macro[TiGetClient(BL(v_cost_tile[i]))]->cy() + (powerplan_width - diff_v)));
									break;
								}
								else if(bottom_empty && !macro[TiGetClient(TR(v_cost_tile[i]))]->is_fixed()){
									macro[TiGetClient(TR(v_cost_tile[i]))]->updateXY(make_pair(macro[TiGetClient(TR(v_cost_tile[i]))]->cx(), macro[TiGetClient(TR(v_cost_tile[i]))]->cy() - (powerplan_width - diff_v)));
									break;
								}
							}
						}
						else{
							if(alpha * diff_h < beta * sqrt(diff_h * diff_v)){
								double bottom_l = macro[TiGetClient(TR(v_cost_tile[i]))]->x1() - 2 * powerplan_width,
										bottom_r = macro[TiGetClient(TR(v_cost_tile[i]))]->x1(),
										bottom_t = macro[TiGetClient(TR(v_cost_tile[i]))]->y2() + min_spacing,
										bottom_b = macro[TiGetClient(TR(v_cost_tile[i]))]->y1() - min_spacing;
								if(bottom_l < 0) bottom_l = 0;
								if(bottom_b < 0) bottom_b = 0;
								if(bottom_t > chip_height) bottom_t = chip_height;
								double top_l = macro[TiGetClient(BL(v_cost_tile[i]))]->x2(),
										top_r = macro[TiGetClient(BL(v_cost_tile[i]))]->x2() + 2 * powerplan_width,
										top_t = macro[TiGetClient(BL(v_cost_tile[i]))]->y2() + min_spacing,
										top_b = macro[TiGetClient(BL(v_cost_tile[i]))]->y1() - min_spacing;
								if(top_r > chip_width) top_r = chip_width;
								if(top_b < 0) top_b = 0;
								if(top_t > chip_height) top_t = chip_height;
								bool bottom_e = true, top_e = true;
								if(bottom_r - bottom_l - diff_h < powerplan_width){
									bottom_e = false;
								}
								else{
									Rect bottom_ = { {bottom_l, bottom_b}, {bottom_r, bottom_t} };
									TiSrArea(NULL, vertical_plane, &bottom_, empty_region, (ClientData)&bottom_e);
								}
								if(top_r - top_l - diff_h < powerplan_width){
									top_e = false;
								}
								else{
									Rect top_ = { {top_l, top_b}, {top_r, top_t} };
									TiSrArea(NULL, vertical_plane, &top_, empty_region, (ClientData)&top_e);
								}
								if(bottom_e && !macro[TiGetClient(TR(v_cost_tile[i]))]->is_fixed()){
									macro[TiGetClient(TR(v_cost_tile[i]))]->updateXY(make_pair(macro[TiGetClient(TR(v_cost_tile[i]))]->cx() - diff_h, macro[TiGetClient(TR(v_cost_tile[i]))]->cy()));
									break;
								}
								else if(top_e && !macro[TiGetClient(BL(v_cost_tile[i]))]->is_fixed()){
									macro[TiGetClient(BL(v_cost_tile[i]))]->updateXY(make_pair(macro[TiGetClient(BL(v_cost_tile[i]))]->cx() + diff_h, macro[TiGetClient(BL(v_cost_tile[i]))]->cy()));
									break;
								}
							}
						}
					}
				}
			}
		}
	}
}

void improve_strategy4(Graph& Gh, Graph& Gv, vector<Macro*>& macro, const vector<Macro*>& native_macro){
	
	vector<edge>* h_edge_list = Gh.get_edge_list();
	vector<edge>* v_edge_list = Gv.get_edge_list();
	vector<edge>* r_h_edge_list = Gh.get_reverse_edge_list();
	vector<edge>* r_v_edge_list = Gv.get_reverse_edge_list();
	
	vector<double> displacement;
	double mean = 0;
	for(int i = 0; i < macro.size(); i++){
		double dist = std::abs(native_macro[i]->x1() - macro[i]->x1()) + std::abs(native_macro[i]->y1() - macro[i]->y1());
		displacement.push_back(dist);
		mean += dist;
	}
	mean = mean / macro.size();
	double vari = 0;
    for (int i = 0; i < macro.size(); i++){
        vari += pow(displacement[i] - mean, 2);
	}
	vari = vari / macro.size();
	double SD = sqrt(vari); // Standard Deviation
	vector<int> access_order;
	for(int i = 0; i < macro.size(); i++){
		access_order.push_back(i);
	}
	std::random_shuffle(access_order.begin(), access_order.end());
	int count = 0; 
	for(int i = 0; i < macro.size() && count++ < 5; i++){
		if(displacement[access_order[i]] > mean && !macro[access_order[i]]->is_fixed()){
			//	restore macro back to original position
			int moved_macro = access_order[i];
			macro[moved_macro]->updateXY(make_pair(native_macro[moved_macro]->cx(), native_macro[moved_macro]->cy()));
			//  add patch edges (a -> moved -> b) =====> (a -> b).
			//	==================================================
			for(int a = 0; a < r_h_edge_list[moved_macro + 1].size(); a++){
				for(int b = 0; b < h_edge_list[moved_macro + 1].size(); b++){
					if(r_h_edge_list[moved_macro + 1][a].from == 0 && h_edge_list[moved_macro + 1][b].to == macros_num + 1){
						continue;
					}
					else if(r_h_edge_list[moved_macro + 1][a].from == 0){
						Gh.add_edge(0, h_edge_list[moved_macro + 1][b].to, macro[h_edge_list[moved_macro + 1][b].to - 1]->w() / 2);
					}
					else if(h_edge_list[moved_macro + 1][b].to == macros_num + 1){
						Gh.add_edge(r_h_edge_list[moved_macro + 1][a].from, macros_num + 1, macro[r_h_edge_list[moved_macro + 1][a].from - 1]->w() / 2);
					}
					else if(macro[r_h_edge_list[moved_macro + 1][a].from - 1]->name() == "null" || macro[h_edge_list[moved_macro + 1][b].to - 1]->name() == "null"){
						double edge_weight = (macro[r_h_edge_list[moved_macro + 1][a].from - 1]->w() + macro[h_edge_list[moved_macro + 1][b].to - 1]->w()) / 2;
						Gh.add_edge(r_h_edge_list[moved_macro + 1][a].from, h_edge_list[moved_macro + 1][b].to, edge_weight);
					}
					else{
						double edge_weight = (macro[r_h_edge_list[moved_macro + 1][a].from - 1]->w() + macro[h_edge_list[moved_macro + 1][b].to - 1]->w()) / 2 + min_spacing;
						Gh.add_edge(r_h_edge_list[moved_macro + 1][a].from, h_edge_list[moved_macro + 1][b].to, edge_weight);
					}
				}
			}
			for(int a = 0; a < r_v_edge_list[moved_macro + 1].size(); a++){
				for(int b = 0; b < v_edge_list[moved_macro + 1].size(); b++){
					if(r_v_edge_list[moved_macro + 1][a].from == 0 && v_edge_list[moved_macro + 1][b].to == macros_num + 1){
						continue;
					}
					else if(r_v_edge_list[moved_macro + 1][a].from == 0){
						Gv.add_edge(0, v_edge_list[moved_macro + 1][b].to, macro[v_edge_list[moved_macro + 1][b].to - 1]->h() / 2);
					}
					else if(v_edge_list[moved_macro + 1][b].to == macros_num + 1){
						Gv.add_edge(r_v_edge_list[moved_macro + 1][a].from, macros_num + 1, macro[r_v_edge_list[moved_macro + 1][a].from - 1]->h() / 2);
					}
					else if(macro[r_v_edge_list[moved_macro + 1][a].from - 1]->name() == "null" || macro[v_edge_list[moved_macro + 1][b].to - 1]->name() == "null"){
						double edge_weight = (macro[r_v_edge_list[moved_macro + 1][a].from - 1]->h() + macro[v_edge_list[moved_macro + 1][b].to - 1]->h()) / 2;
						Gv.add_edge(r_v_edge_list[moved_macro + 1][a].from, v_edge_list[moved_macro + 1][b].to, edge_weight);
					}
					else{
						double edge_weight = (macro[r_v_edge_list[moved_macro + 1][a].from - 1]->h() + macro[v_edge_list[moved_macro + 1][b].to - 1]->h()) / 2 + min_spacing;
						Gv.add_edge(r_v_edge_list[moved_macro + 1][a].from, v_edge_list[moved_macro + 1][b].to, edge_weight);
					}
				}
			}
			//	==================================================
			//	remove edges connect to restored macro
			vector<int> target_connected_to, connected_to_target;	// range of stored values is [0, macros_num + 1]
			for (auto &e : h_edge_list[moved_macro + 1]){
				target_connected_to.push_back(e.to);
			}
			for (auto &e : r_h_edge_list[moved_macro + 1]){
				connected_to_target.push_back(e.from);
			}
			for(int j = 0; j < target_connected_to.size(); j++){
				Gh.remove_edge(moved_macro + 1, target_connected_to[j]);
			}
			for(int j = 0; j < connected_to_target.size(); j++){
				Gh.remove_edge(connected_to_target[j], moved_macro + 1);
			}
			target_connected_to.clear();
			connected_to_target.clear();
			for (auto &e : v_edge_list[moved_macro + 1]){
				target_connected_to.push_back(e.to);
			}
			for (auto &e : r_v_edge_list[moved_macro + 1]){
				connected_to_target.push_back(e.from);
			}
			for(int j = 0; j < target_connected_to.size(); j++){
				Gv.remove_edge(moved_macro + 1, target_connected_to[j]);
			}
			for(int j = 0; j < connected_to_target.size(); j++){
				Gv.remove_edge(connected_to_target[j], moved_macro + 1);
			}
			// // add (source-macro) and (macro-sink) edges
			add_st_nodes(Gh, Gv, macro[moved_macro]);
			add_macro_to_graph(Gh, Gv, macro, moved_macro, false);
			//break;
		}
	}
}

void improve_strategy5(vector<Macro*>& macro, Plane* horizontal_plane, Plane* vertical_plane, Graph& Gh, Graph& Gv){

	vector<edge>* h_edge_list = Gh.get_edge_list();
	vector<edge>* v_edge_list = Gv.get_edge_list();
	vector<edge>* r_h_edge_list = Gh.get_reverse_edge_list();
	vector<edge>* r_v_edge_list = Gv.get_reverse_edge_list();

	vector<Tile*> horizontal_tiles;
	vector<Tile*> vertical_tiles;

	Rect horizontal_region = { {0, 0}, {chip_width, chip_height} };
	Rect vertical_region = {{-chip_height, 0}, {0, chip_width}};	
	
	TiSrArea(NULL, horizontal_plane, &horizontal_region, collectSolidTiles, (ClientData)&horizontal_tiles);
	TiSrArea(NULL, vertical_plane, &vertical_region, collectSolidTiles, (ClientData)&vertical_tiles);
	vector<Tile*> h_cost_tile;
	// Iterative go through solid tiles find out cost tiles
	for(int i = 0; i < horizontal_tiles.size(); i++){
		if(TiGetClient(horizontal_tiles[i]) == -1)
			h_cost_tile.push_back(horizontal_tiles[i]);
	}
	// std::sort(h_cost_tile.begin(), h_cost_tile.end(), cost_tile_cmp);
	std::random_shuffle(h_cost_tile.begin(), h_cost_tile.end());
	vector<Tile*> v_cost_tile;
	for(int i = 0; i < vertical_tiles.size(); i++){
		if(TiGetClient(vertical_tiles[i]) == -1)
			v_cost_tile.push_back(vertical_tiles[i]);
	}
	// std::sort(v_cost_tile.begin(), v_cost_tile.end(), cost_tile_cmp);
	std::random_shuffle(v_cost_tile.begin(), v_cost_tile.end());
	bool found = false;
	int count = 0;
	if(rand() % 2){
		for(int i = 0; i < h_cost_tile.size(); i++){
			// This cost tile is generated by two macros(left - right)
			if(TiGetBody(BL(h_cost_tile[i])) == SOLID_TILE && TiGetBody(TR(h_cost_tile[i])) == SOLID_TILE &&
				TiGetClient(BL(h_cost_tile[i])) != -1 && TiGetClient(TR(h_cost_tile[i])) != -1){
				// Do not space e(macro, null)
				if(macro[TiGetClient(BL(h_cost_tile[i]))]->name() != "null" && macro[TiGetClient(TR(h_cost_tile[i]))]->name() != "null"){		
					for(int j = 0; j < h_edge_list[TiGetClient(BL(h_cost_tile[i])) + 1].size(); j++){
						if(h_edge_list[TiGetClient(BL(h_cost_tile[i])) + 1][j].to - 1 == TiGetClient(TR(h_cost_tile[i]))){
							h_edge_list[TiGetClient(BL(h_cost_tile[i])) + 1][j].weight = (macro[TiGetClient(BL(h_cost_tile[i]))]->w() + macro[TiGetClient(TR(h_cost_tile[i]))]->w()) / 2 + powerplan_width;
						}
					}
					for(int j = 0; j < r_h_edge_list[TiGetClient(TR(h_cost_tile[i])) + 1].size(); j++){
						if(r_h_edge_list[TiGetClient(TR(h_cost_tile[i])) + 1][j].from - 1 == TiGetClient(BL(h_cost_tile[i]))){
							r_h_edge_list[TiGetClient(TR(h_cost_tile[i])) + 1][j].weight = (macro[TiGetClient(BL(h_cost_tile[i]))]->w() + macro[TiGetClient(TR(h_cost_tile[i]))]->w()) / 2 + powerplan_width;
							count++;
						}
					}
				}
			}
			if(count > 5){
				break;
			}
		}
	}
	else{
		for(int i = 0; i < v_cost_tile.size(); i++){
			if(TiGetBody(BL(v_cost_tile[i])) == SOLID_TILE && TiGetBody(TR(v_cost_tile[i])) == SOLID_TILE &&
				TiGetClient(BL(v_cost_tile[i])) != -1 && TiGetClient(TR(v_cost_tile[i])) != -1){
				// Do not space e(macro, null)
				if(macro[TiGetClient(BL(v_cost_tile[i]))]->name() != "null" && macro[TiGetClient(TR(v_cost_tile[i]))]->name() != "null"){
					for(int j = 0; j < v_edge_list[TiGetClient(TR(v_cost_tile[i])) + 1].size(); j++){
						if(v_edge_list[TiGetClient(TR(v_cost_tile[i])) + 1][j].to - 1 == TiGetClient(BL(v_cost_tile[i]))){
							v_edge_list[TiGetClient(TR(v_cost_tile[i])) + 1][j].weight = (macro[TiGetClient(TR(v_cost_tile[i]))]->h() + macro[TiGetClient(BL(v_cost_tile[i]))]->h()) / 2 + powerplan_width;
						}
					}
					for(int j = 0; j < r_v_edge_list[TiGetClient(BL(v_cost_tile[i])) + 1].size(); j++){
						if(r_v_edge_list[TiGetClient(BL(v_cost_tile[i])) + 1][j].from - 1 == TiGetClient(TR(v_cost_tile[i]))){
							r_v_edge_list[TiGetClient(BL(v_cost_tile[i])) + 1][j].weight = (macro[TiGetClient(TR(v_cost_tile[i]))]->h() + macro[TiGetClient(BL(v_cost_tile[i]))]->h()) / 2 + powerplan_width;
							count++;
						}
					}
				}
			}
			if(count > 5){
				break;
			}
		}
	}
}